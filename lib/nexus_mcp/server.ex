defmodule NexusMCP.Server do
  @moduledoc """
  Behaviour for defining an MCP server.

  ## Usage

  ### Manual style (tools/0 + handle_tool_call/3)

      defmodule MyApp.MCP do
        use NexusMCP.Server,
          name: "my-app",
          version: "1.0.0"

        @impl true
        def tools do
          [
            %{name: "hello", description: "Say hello", inputSchema: %{type: "object", properties: %{}}}
          ]
        end

        @impl true
        def handle_tool_call("hello", _params, _session) do
          {:ok, "Hello, world!"}
        end
      end

  ### DSL style (deftool + wrap_tool_call)

      defmodule MyApp.MCP do
        use NexusMCP.Server,
          name: "my-app",
          version: "1.0.0"

        @impl true
        def wrap_tool_call(session, fun) do
          MyApp.Context.put_user_id(session.assigns[:user_id])
          fun.()
        rescue
          Ecto.NoResultsError -> {:error, "Not found"}
        end

        deftool "list_pages", "List all pages", params: [] do
          {:ok, Enum.map(CMS.list_pages(), &Map.take(&1, [:id, :title, :slug]))}
        end

        deftool "get_page", "Get a page by ID",
          params: [id: {:string!, "Page ID"}] do
          page = CMS.get_page!(params["id"])
          {:ok, Map.take(page, [:id, :title, :slug, :body, :updated_at])}
        end
      end

  ## Options

  - `:name` - Server name (required)
  - `:version` - Server version (required)
  - `:idle_timeout` - Session idle timeout in ms (default: 7_200_000 / 2 hours)
  """

  @type session :: %{
          session_id: String.t(),
          assigns: map()
        }

  @doc """
  Returns the list of tool definitions.
  """
  @callback tools() :: [map()]

  @doc """
  Handle a tool call. Receives the tool name, params, and session state.
  """
  @callback handle_tool_call(name :: String.t(), params :: map(), session :: session()) ::
              {:ok, term()} | {:error, String.t()}

  @doc """
  Per-session initialization. Called when a new session is created.
  Receives the session map and should return `{:ok, session}` or `{:error, reason}`.
  """
  @callback init(session :: session()) :: {:ok, session()} | {:error, String.t()}

  @doc """
  Returns server info (name, version). Generated by `use NexusMCP.Server`.
  """
  @callback server_info() :: %{name: String.t(), version: String.t()}

  @doc """
  Returns the idle timeout in milliseconds.
  """
  @callback idle_timeout() :: non_neg_integer()

  @doc """
  Wraps every tool call execution. Runs in the Task process before the handler.
  Override to set up process-local state (e.g. tenant context) or rescue errors.

  Default implementation just calls `fun.()`.
  """
  @callback wrap_tool_call(session :: session(), fun :: (-> {:ok, term()} | {:error, String.t()})) ::
              {:ok, term()} | {:error, String.t()}

  defmacro __using__(opts) do
    name = Keyword.fetch!(opts, :name)
    version = Keyword.fetch!(opts, :version)
    idle_timeout = Keyword.get(opts, :idle_timeout, 7_200_000)

    quote do
      @behaviour NexusMCP.Server

      Module.register_attribute(__MODULE__, :__nexus_tools__, accumulate: true)
      @before_compile NexusMCP.Server.Tool

      import NexusMCP.Server.Tool, only: [deftool: 3, deftool: 4, format_changeset_errors: 1]

      @doc false
      @impl NexusMCP.Server
      def server_info do
        %{name: unquote(name), version: unquote(version)}
      end

      @doc false
      @impl NexusMCP.Server
      def idle_timeout do
        unquote(idle_timeout)
      end

      @impl NexusMCP.Server
      def init(session), do: {:ok, session}

      @impl NexusMCP.Server
      def wrap_tool_call(_session, fun), do: fun.()

      defoverridable init: 1, wrap_tool_call: 2
    end
  end
end
